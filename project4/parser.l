%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "y.tab.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();
%}

%option yylineno

%%

boolean               { return KW_BOOLEAN;            }
class                 { return KW_CLASS;              }
false                 { return KW_FALSE;              }
true                  { return KW_TRUE;               }
int                   { return KW_INT;                }
main                  { return MAIN;                  }
public                { return KW_PUBLIC;             }
private               { return KW_PRIVATE;            }
static                { return KW_STATIC;             }
String                { return KW_STRING;             }
System\.out\.print    { return SYSTEM_OUT_PRINT;      }
System\.out\.println  { return SYSTEM_OUT_PRINTLN;    }
Integer\.parseInt     { return INTEGER_PARSEINT;      }
length                { return KW_LENGTH;             }
void                  { return KW_VOID;               }
if                    { return KW_IF;                 }
else                  { return KW_ELSE;               }
while                 { return KW_WHILE;              }
return                { return KW_RETURN;             }
new                   { return KW_NEW;                }


    /* comment */
"//".* {
  //printf("inline_comment: %s\n", yytext);
}
"/*"([^*]|"*"+[^/*])*"*""/" {
 // printf("block comment: %s\n", yytext);
}

    /* catching ++ and -- */
"++" {
  //printf("++\n");
}

"--" {
  //printf("--\n");
}

  /* opeartors */
"&&" {
   //printf("&&\n");
   return TOK_AND;
}

"||" {
   //printf("||\n");
   return TOK_OR;
}

"<" {
   //printf("<\n");
   return *yytext;
}

">" {
   //printf(">\n");
   return *yytext;
}

"<=" {
   //printf("<=\n");
   return TOK_LESSEQL;
}

">=" {
   //printf(">=\n");
   return TOK_GREATEQL;
}

"==" {
   //printf("==\n");
   return TOK_EQUAL;
}

"!=" {
   //printf("!=\n");
   return TOK_NOTEQL;
}

"+" {
   //printf("+\n");
   return *yytext;
}

"-" {
   //printf("-\n");
   return *yytext;
}

"*" {
   //printf("*\n");
   return *yytext;
}

"/" {
   //printf("/\n");
   return *yytext;
}

"("|")"|"["|"]"|"{"|"}"|"="|"."|";"|","|"!" {
   //printf("%s\n", yytext);
   return *yytext;
}



[0-9]+ {
    yylval.integer = atoi(strdup(yytext));
    return INTEGER_LITERAL;
}

[a-zA-Z][a-zA-Z0-9_]* {
    yylval.string = strdup(yytext);
    //printf("%s\n", yytext);
    return ID;                 
}

\"([^"\\]|\\.)*\" {
    yylval.string = strdup(yytext);
    return STRING_LITERAL;                    
}


[ \t\n]               { } /* skip whitespace */

%%

int yywrap(void) {
    return 1;
}