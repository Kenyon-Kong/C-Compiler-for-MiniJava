    In project 2, I implement a bottom up parser capable of type-checking. In this project, I use Lex and Yacc to detect the input file and build the grammar. While Yacc recognizes the grammar, I will also build the Abstract Syntax Tree on the way. Then I write a C program to implement type-checking, with the help of the AST. I traverse the AST two times for checking re-declaration as well as types-mismatch, and details will be explained later.
    The first part of the project is the implementation of Lex and Yacc(file parser.l & parser.y). Before turning the grammar rule into Yacc, I pre-processed the extended BNF given into BNF which avoids right recursive rules as possible. (But it turns out after changing some right-recursive rules into left-recursive will actually disrupt the building of AST, thus I leave them to remain right-recursive, and also not cause any parsing conflict.) After I have the correct grammar rules, I translate all those rules into Lex and Yacc. For the lex program, I have tokens for java keywords like “private”, “false”, etc, and tokens for operators such as “+”, “==”, etc(however, if the operator only contains a single character, I simply just return *yytext, if not, I return a token label which I created). After specifying all the token types in lex, I use all these tokens in my Yacc program. First of all, I create each non-terminal in my grammar with its own rule using the syntax in Yacc. To build the AST alongside the grammar recognition, I used the same style as given in the skeleton code. For each rule, I create a AST node of the left-hand side non-terminal with the specific NOTETYPE(for special rules correspond to later type checking, I assign special names such as NODETYPE_OPERATION for Exp op Exp rule, or for if&while statements I have them named NODETYPE_IF/WHILE, which will be used in traversals to distinguish what type-checking procedures the parser needs to perform), then for every right-hand side non-terminals, I add it to the left-hand side AST node. Since the YACC builds the grammar in bottom up(recursive-ish) style, at that time of adding all the right-hand non-terminals, they would already be constructed(For some null rules, I detect if the child equals to NULL, if yes, just skip that child). In addition, if ID appears in the right hand side, I will set the node data value of the value of ID. In details, my AST node contains: the access to its children and parent AST nodes, the line number of the node, its NODETYPE, number of children, a pointer points to its symbol table, and finally a Boolean variable to indicates whether we need to create a new scope(which, set to true if the current rules contains ‘{‘ ‘}’). 
    Then in the typecheck.c file which contains all the methods for type-checking, there are 2 essential recursive functions called first-traversal, and second-traversal. In the first traversal, the function starts from the root of the AST tree, and recursive all its root in a DFS style. In the first traversal, the algorithm will check all the type violations which can be done without using the symbol table, and also build up the symbol table. Works like this: 1) Then the algorithm will check each node’s NODETYPE to see what actions need to be done. 2) for nodes with new scope, it will create a new symbol table, and let the table link to its parent node; Or for value declarations, it will add the variable into the symbol table while checking the left or right type, whether they satisfied the requirement; Or for method declarations, we will add it to the Global method table, etc. Then after finishing the first traversal, after we have the method and symbol table, our second traversal will use these tables to typecheck. For example, for nodes with type NODETYPE_OPERATION, which correspond to grammar rule Exp op Exp, we will use the table to check if the types correspond to each other by going down the AST tree to check the type (checking table if necessary). Also we will check method calls using the method table to see the corresponding arguments and return type. 
    The general structure of the parser is described above, I omit many implementation details since I have tons of helper functions and each of them responds to a specific request. Also, I wrote the functions to print out tables and ASTs. To conclude, we will have 3 structures, one for AST tree, one for Table nodes(each node corresponds to a new scope), and a global array for methods. And in first traversing we will fill up the table and do as many type checking as we can. Then in the second traversal, we will use the information stores in the tables, and perform the rest of the type checking. After collecting all errors and putting it into an error array, we will call a function to sort the line number, then output the line number.   
