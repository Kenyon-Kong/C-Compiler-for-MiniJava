README
	In project 3 I implemented the basic Assembly code generator for a subset of MiniJava language in project 2.  The general idea is to traverse the AST syntax tree I built in Project 2 one more time to handle the translation between Java and assembly. The generation of assembly includes two parts, one for translating the Java into 3AC pseudo assembly,  and the other one for  reshaping the 3AC language into real assembly.
	The first part is handled in the function called thirdTraversal,  which does a button up traversal to the AST syntax tree. To implement a button up style, instead of putting the For-Loop containing the recursive calls at the very end as I did in Project 2 when building the tree, I drag the for-loop at the very front of this function so it would traverse to the leaves first. Then I did in Project 2, when encountering a certain node type,  I translated the JAVA language into a certain form of 3AC as shown in the lecture slides, and used a linked list to store all those 3AC nodes. Method declarations need more complicated implementation. Instead of just appending new notes into the tail of the linked list, I inserted them in the correct position. The 3AC code contained in each of the 3AC nodes now contains symbolic registers “$tx”, which cannot be used in the real assembly. To solve this problem, I assigned the register offset to each of the registers that would be used in the real assembly. Besides that I also linked the certain 3AC nodes with the corresponding AST node which lets me use the tree structure in traversing the linked list.
	And the second part is handled in a function called outputASM,  which traverses the linked list containing all the 3AC nodes from the root, and translating each of the 3AC assembly code into real assembly code.  It works in the same style as traversing the tree, which when encountering  a certain type of 3AC nodes, function would do a certain type of translation as shown in these slides but with more detail implemented. However, at this time the node type is the type I created only for the 3AC nodes. And during translating I translate all the symbolic registers into the real registers r0, r1, …, etc,  then I fill these registers with their offset. By making a label for each of the methods declared, when encountering a method call, I can simply branch to the label,  and return to the main function after being done in the method.
Above all is the general idea of how I implemented project 3. 
