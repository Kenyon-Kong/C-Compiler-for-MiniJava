## Documentation for CS 352 - Compiler projects

## Project 2
 In project 2, I implement a bottom up parser capable of type-checking. In this project, I use Lex and Yacc to detect the input file and build the grammar. While Yacc recognizes the grammar, I will also build the Abstract Syntax Tree on the way. Then I write a C program to implement type-checking, with the help of the AST. I traverse the AST two times for checking re-declaration as well as types-mismatch, and details will be explained later.
    The first part of the project is the implementation of Lex and Yacc(file parser.l & parser.y). Before turning the grammar rule into Yacc, I pre-processed the extended BNF given into BNF which avoids right recursive rules as possible. (But it turns out after changing some right-recursive rules into left-recursive will actually disrupt the building of AST, thus I leave them to remain right-recursive, and also not cause any parsing conflict.) After I have the correct grammar rules, I translate all those rules into Lex and Yacc. For the lex program, I have tokens for java keywords like “private”, “false”, etc, and tokens for operators such as “+”, “==”, etc(however, if the operator only contains a single character, I simply just return *yytext, if not, I return a token label which I created). After specifying all the token types in lex, I use all these tokens in my Yacc program. First of all, I create each non-terminal in my grammar with its own rule using the syntax in Yacc. To build the AST alongside the grammar recognition, I used the same style as given in the skeleton code. For each rule, I create a AST node of the left-hand side non-terminal with the specific NOTETYPE(for special rules correspond to later type checking, I assign special names such as NODETYPE_OPERATION for Exp op Exp rule, or for if&while statements I have them named NODETYPE_IF/WHILE, which will be used in traversals to distinguish what type-checking procedures the parser needs to perform), then for every right-hand side non-terminals, I add it to the left-hand side AST node. Since the YACC builds the grammar in bottom up(recursive-ish) style, at that time of adding all the right-hand non-terminals, they would already be constructed(For some null rules, I detect if the child equals to NULL, if yes, just skip that child). In addition, if ID appears in the right hand side, I will set the node data value of the value of ID. In details, my AST node contains: the access to its children and parent AST nodes, the line number of the node, its NODETYPE, number of children, a pointer points to its symbol table, and finally a Boolean variable to indicates whether we need to create a new scope(which, set to true if the current rules contains ‘{‘ ‘}’). 
    Then in the typecheck.c file which contains all the methods for type-checking, there are 2 essential recursive functions called first-traversal, and second-traversal. In the first traversal, the function starts from the root of the AST tree, and recursive all its root in a DFS style. In the first traversal, the algorithm will check all the type violations which can be done without using the symbol table, and also build up the symbol table. Works like this: 1) Then the algorithm will check each node’s NODETYPE to see what actions need to be done. 2) for nodes with new scope, it will create a new symbol table, and let the table link to its parent node; Or for value declarations, it will add the variable into the symbol table while checking the left or right type, whether they satisfied the requirement; Or for method declarations, we will add it to the Global method table, etc. Then after finishing the first traversal, after we have the method and symbol table, our second traversal will use these tables to typecheck. For example, for nodes with type NODETYPE_OPERATION, which correspond to grammar rule Exp op Exp, we will use the table to check if the types correspond to each other by going down the AST tree to check the type (checking table if necessary). Also we will check method calls using the method table to see the corresponding arguments and return type. \

## Projec 3
   In project 3 I implemented the basic Assembly code generator for a subset of MiniJava language in project 2.  The general idea is to traverse the AST syntax tree I built in Project 2 one more time to handle the translation between Java and assembly. The generation of assembly includes two parts, one for translating the Java into 3AC pseudo assembly,  and the other one for  reshaping the 3AC language into real assembly.
	The first part is handled in the function called thirdTraversal,  which does a button up traversal to the AST syntax tree. To implement a button up style, instead of putting the For-Loop containing the recursive calls at the very end as I did in Project 2 when building the tree, I drag the for-loop at the very front of this function so it would traverse to the leaves first. Then I did in Project 2, when encountering a certain node type,  I translated the JAVA language into a certain form of 3AC as shown in the lecture slides, and used a linked list to store all those 3AC nodes. Method declarations need more complicated implementation. Instead of just appending new notes into the tail of the linked list, I inserted them in the correct position. The 3AC code contained in each of the 3AC nodes now contains symbolic registers “$tx”, which cannot be used in the real assembly. To solve this problem, I assigned the register offset to each of the registers that would be used in the real assembly. Besides that I also linked the certain 3AC nodes with the corresponding AST node which lets me use the tree structure in traversing the linked list.
 	And the second part is handled in a function called outputASM,  which traverses the linked list containing all the 3AC nodes from the root, and translating each of the 3AC assembly code into real assembly code.  It works in the same style as traversing the tree, which when encountering  a certain type of 3AC nodes, function would do a certain type of translation as shown in these slides but with more detail implemented. However, at this time the node type is the type I created only for the 3AC nodes. And during translating I translate all the symbolic registers into the real registers r0, r1, …, etc,  then I fill these registers with their offset. By making a label for each of the methods declared, when encountering a method call, I can simply branch to the label,  and return to the main function after being done in the method.
Above all is the general idea of how I implemented project 3. 
 The general structure of the parser is described above, I omit many implementation details since I have tons of helper functions and each of them responds to a specific request. Also, I wrote the functions to print out tables and ASTs. To conclude, we will have 3 structures, one for AST tree, one for Table nodes(each node corresponds to a new scope), and a global array for methods. And in first traversing we will fill up the table and do as many type checking as we can. Then in the second traversal, we will use the information stores in the tables, and perform the rest of the type checking. After collecting all errors and putting it into an error array, we will call a function to sort the line number, then output the line number.  

## Project 4
  First of all, before I began working on Project 4, I fixed the bugs from Project 3.
New features expand after Project 3:
Add instruction to handle bool type:
		I declared the bool type as numeric based on the lecture slides, if it’s true, then its numerical value is 1, otherwise is 0. Then when the bool variable is used in the condition statement in branches, I will compare it with 0. Similarly, I also handle bool values extracted from variables.
Branches
		For if and while, I basically implement it as the slides suggest, however, the slides are lacking the implementation details on how to find the corresponding position, such as where is the first instruction of the then-body or else-body. So what I did is instead of finding the “first” instruction, I found the “last” instruction for the previous section, then inserted the corresponding label of “while_lable” or “if_else_lable” after the “last” instruction I found. Then the rest of the implementation is just really similar to the slides.
Array
		For a one dimensional array, I get the exp register as index, then use it to create (call malloc) or access the array entry (by ldr itself again using the index). For the two dimensional array declaration, I used the same structure as the while loop to iteratively assign a two dimensional malloc address to the one dimensional array address. And for accessing the two dimensional array entries, I find the address for the one dimensional base address the access again as its another array.
	Then the rest of the processes are just spending a really long time debugging. 

 ## Project 5
   To start up with project 5, the first thing I did was delete all the parts that are not in this project, such as array declarations, and all the instructions related to array. Then kind of starting again from the beginning to formulate the 3AC code, because for some of the instructions in project 2-4, I directly translated them into real assembly instead of using 3AC as a medium step. Then after I divided all instructions into proper 3AC, I also updated their use and def in building the instruction flow. After that, I linked the instructions with their predecessor and successor by traversing the node and finding their corresponding labels.  Then I create a function to calculate the liveness of each real register or symbolic register by traversing the instruction flow from the end and propagating the liveIn and liveOut to the top. I use a stack to handle the repetition due to updating the predecessors. The procedure of calculating the liveness is the same as the lecture slides. 
After getting liveness analysis done, I build the inference graph for each of the methods, such as “main” and other static methods. The graph is stored as an array of struct nodes.  I create each of the graph nodes first, then link them together with their neighbors by traversing the liveness. And finally, I color them using the instructions mentioned in the lecture slides. For caller and callee saves, I put all such regs to the stack, and restore it before returning to the parent call.  
Lastly,  is the long process of debugging.
