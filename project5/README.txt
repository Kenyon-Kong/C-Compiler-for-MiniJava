To start up with project 5, the first thing I did was delete all the parts that are not in this project, such as array declarations, and all the instructions related to array. Then kind of starting again from the beginning to formulate the 3AC code, because for some of the instructions in project 2-4, I directly translated them into real assembly instead of using 3AC as a medium step. Then after I divided all instructions into proper 3AC, I also updated their use and def in building the instruction flow. After that, I linked the instructions with their predecessor and successor by traversing the node and finding their corresponding labels.  Then I create a function to calculate the liveness of each real register or symbolic register by traversing the instruction flow from the end and propagating the liveIn and liveOut to the top. I use a stack to handle the repetition due to updating the predecessors. The procedure of calculating the liveness is the same as the lecture slides. 
After getting liveness analysis done, I build the inference graph for each of the methods, such as “main” and other static methods. The graph is stored as an array of struct nodes.  I create each of the graph nodes first, then link them together with their neighbors by traversing the liveness. And finally, I color them using the instructions mentioned in the lecture slides. For caller and callee saves, I put all such regs to the stack, and restore it before returning to the parent call.  
Lastly,  is the long process of debugging.

